<!DOCTYPE html>
<html>

<head>
    <title>
        SRTF Theory
    </title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
</head>
<nav style="border-radius:0%" class="navbar navbar-expand-sm navbar-dark bg-dark fixed-top">
    <div class="container-fluid">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mynavbar">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="mynavbar">
           
        <button type="button" class="btn btn-outline-success btn-lg btn-radius"
            onclick="window.location.href = '../index.html';"
            style="color: rgb(255, 255, 255); background-color:  black;">
            Back to Home
        </button>
    </div>
    </div>
</nav>
<br><br><br>

<style>
    .btn {
        border-radius: 20px;
        background-color: #e0e6e0;
        color: black;
    }
</style>

<body>
    <div class="container">
        <br><br><br><br>
        <h1>
            <b>Disk Scheduling Algorithms</b>
        </h1>
        <h2>
            Theory
        </h2>
        <br><br>
        <p>
            Disk scheduling is done by operating systems to schedule I/O requests arriving for the disk. Disk scheduling
            is also known as I/O scheduling. </p>
        <p>
        <p>
            Disk scheduling is important because:
        <ul>
            <li> Two or more request may be far from each other so can result in greater disk arm movement.</li>
            <li>Multiple I/O requests may arrive by different processes and only one I/O request can be served at a time
                by the disk controller. Thus other I/O requests need to wait in the waiting queue and need to be
                scheduled.</li>
            <li> Hard drives are one of the slowest parts of the computer system and thus need to be accessed in an
                efficient manner.</li>
        </ul>
        </p>
        <p>
            There are many Disk Scheduling Algorithms but before discussing them letâ€™s have a quick look at some
            of the important terms:
        <ul>
            <li> <b>Seek Time</b> : It is the time taken to locate the disk arm to a specified track where the
                data is to be read or write. So the disk scheduling algorithm that gives minimum average seek
                time is better. </li>
            <li> <b>Rotational Latency</b>: Rotational Latency is the time taken by the desired sector of disk
                to rotate into a position so that it can access the read/write heads. So the disk scheduling
                algorithm that gives minimum rotational latency is better.</li>
            <li> <b>Transfer Time</b>: Transfer time is the time to transfer the data. It depends on the
                rotating speed of the disk and number of bytes to be transferred.</li>
            <li> <b>Disk Access Time</b>: Disk Access Time is:
                Disk Access Time = Seek Time + Rotational Latency + Transfer Time </li>
            <li> <b>Disk Response Time</b>: Response Time is the average of time spent by a request waiting to
                perform its I/O operation. Average Response time is the response time of the all requests.
                Variance Response Time is measure of how individual request are serviced with respect to average
                response time. So the disk schedliing algorithm that gives minimum variance response time is
                better. </li>
        </ul>
        </p>
        </p>
        <p>
        <h2><b>Disk Scheduling Algorithms</b></h2>
        <p>
        <h4><b>FCFS</b></h4>
        <p>
            FCFS is the simplest of all the Disk Scheduling Algorithms. In FCFS, the requests are addressed in the order
            they arrive in the disk queue.
        </p>
        <b>Advantages</b>
        <ul>
            <li> Every request gets a fair chance</li>
            <li> No indefinite postponement</li>
        </ul>
        <b>Disadvantages</b>
        <ul>
            <li> Does not try to optimize seek time</li>
            <li> May not provide the best possible service</li>
        </ul>
        </p>
        <p>
        <h4><b>SCAN</b></h4>
        <p>
            In SCAN algorithm the disk arm moves into a particular direction and services the requests coming in its
            path and after reaching the end of disk, it reverses its direction and again services the request arriving
            in its path. So, this algorithm works as an elevator and hence also known as elevator algorithm. As a
            result, the requests at the midrange are serviced more and those arriving behind the disk arm will have to
            wait.
        </p>
        <b>Advantages</b>
        <ul>
            <li>High throughput</li>
            <li>Low variance of response time</li>
            <li>Average response time</li>
        </ul>
        <b>Disadvantages</b>
        <ul>
            <li> Long waiting time for requests for locations just visited by disk arm</li>
        </ul>
        </p>
        <p>
        <h4><b>C SCAN</b></h4>
        <p>
            In SCAN algorithm, the disk arm again scans the path that has been scanned, after reversing its direction.
            So, it may be possible that too many requests are waiting at the other end or there may be zero or few
            requests pending at the scanned area. These situations are avoided in CSCAN algorithm in which the disk arm
            instead of reversing its direction goes to the other end of the disk and starts servicing the requests from
            there. So, the disk arm moves in a circular fashion and this algorithm is also similar to SCAN algorithm and
            hence it is known as C-SCAN (Circular SCAN).
        </p>
        <b>Advantages</b>
        <ul>
            <li>Provides more uniform wait time compared to SCAN</li>
        </ul>
        <b>Disadvantages</b>
        <ul>
            <li> It causes more seek movements as compared to SCAN Algorithm.</li>
            <li> It causes the head to move till the end of the disk even if there are no requests to be serviced.</li>
        </ul>
        </p>
        <p>
        <h4><b>Shortest Seek Time First (SSTF)</b></h4>
        <p>
            In this algorithm, the shortest seek time is checked from the current position and those requests which have
            the shortest seek time is served first. In simple words, the closest request from the disk arm is served
            first.
        </p>
        <b>Advantages</b>
        <ul>
            <li>Average Response Time decreases</li>
            <li>Throughput increases</li>
        </ul>
        <b>Disadvantages</b>
        <ul>
            <li>Overhead to calculate seek time in advance</li>
            <li>Can cause Starvation for a request if it has higher seek time as compared to incoming requests</li>
            <li>High variance of response time as SSTF favours only some requests</li>
        </ul>
        </p>

        </p>
        <p>
        <h4><b>LOOK</b></h4>
        <p>
            It is similar to the SCAN disk scheduling algorithm except for the difference that the disk arm in spite of
            going to the end of the disk goes only to the last request to be serviced in front of the head and then
            reverses its direction from there only. Thus it prevents the extra delay which occurred due to unnecessary
            traversal to the end of the disk.
        </p>
        <b>Advantages</b>
        <ul>
            <li>It does not causes the head to move till the ends of the disk when there are no requests to be serviced.
            </li>
            <li>It provides better performance as compared to SCAN Algorithm.</li>
            <li>It does not lead to starvation.</li>

        </ul>
        <b>Disadvantages</b>
        <ul>
            <li>Overhead of finding the end requests is present.</li>
            <li>Cylinders which are just visited by Head have to wait for long time.</li>
        </ul>
        </p>
        <h4><b>C-LOOK</b></h4>
        <p>
            This algorithm is also the same as the LOOK algorithm. The only difference between LOOK and C-LOOK is, it
            moves in a particular direction till the last request is found and serves the requests in its path. Then, it
            returns in the opposite direction till the last request is found in that direction and doesn't serve the
            request while returning. Then, again reverses the direction and serves the requests found in the path. It
            also moves circularly.
        </p>
        <div style="margin-left: 0rem;"><p >
            <b>Advantages</b>
        <ul>
            <li>In C-LOOK the head does not have to move till the end of the disk if there are no requests to be
                serviced.
            </li>
            <li>C-LOOK provides better performance when compared to LOOK Algorithm.</li>
            <li>Starvation is avoided in C-LOOK.</li>

        </ul>
        <b>Disadvantages</b>
        <ul>
            <li>In C-LOOK an overhead of finding the end requests is present.</li>

        </ul>
        </p></div>
        </p>

        </p>
        <br>
        <a href="Simulate.html"><button type="button" class="btn btn-outline-secondary">Click here for
                simulation</button></a>

    </div>
</body>

</html>